# ============================================================================
# MODE CONFIGURATION
# ============================================================================
# Mode: "normal" or "test" (case insensitive)
#   - "test": Reads target structure from XYZ file and generates IAM scattering
#   - "normal": Reads target scattering data directly from a DAT file
mode = "normal"

# ============================================================================
# RUN PARAMETERS
# ============================================================================
[run_params]
# Unique identifier for this run (used in output filenames)
run_id = "test"
# Molecule name (must match a section in [molecule_params])
molecule = "chd"
# Directory where results will be saved
results_dir = "results"

# ============================================================================
# FILE PATHS
# ============================================================================
[files]
# Force field file for molecular mechanics calculations (OpenFF format)
forcefield_file = "forcefields/openff_unconstrained-2.0.0.offxml"
# Starting structure in XYZ format
start_xyz_file = "xyz/start.xyz"
# Starting structure in SDF format (alternative to XYZ)
start_sdf_file = "sdf/chd_start.sdf"
# Reference structure for comparison (used for RMSD calculations)
reference_xyz_file = "xyz/chd_reference.xyz"
# Reference DAT file for PCD mode (optional, if provided, uses this instead of calculating from reference_xyz_file)
# If empty string or not provided, reference IAM is calculated from reference_xyz_file
reference_dat_file = "data/chd_reference.dat"
# Target file: XYZ file (for "test" mode) or DAT file (for "normal" mode)
target_file = "xyz/target.xyz"

# ============================================================================
# OPTIONS
# ============================================================================
[options]
# Run normal modes calculation with PySCF (if false, reads from data/modes.npy)
run_pyscf_modes_bool = false
# Basis set for PySCF calculations (e.g., "6-31g*", "sto-3g", "def2-SVP")
pyscf_basis = "6-31g*"
# Enable verbose output (prints all parameters during initialization)
verbose_bool = false
# Write DAT file output with scattering data
write_dat_file_bool = true
# MM parameter retrieval method: "sdf" (try SDF method first, fallback to basic) or "basic" (use basic method directly)
mm_param_method = "basic"

# ============================================================================
# SAMPLING PARAMETERS
# ============================================================================
[sampling]
# Enable Boltzmann sampling of structures
sampling_bool = false
# Temperature (K) for Boltzmann sampling
boltzmann_temperature = 300.0

# ============================================================================
# SCATTERING PARAMETERS
# ============================================================================
[scattering_params]
# Include inelastic (Compton) scattering contribution
inelastic_bool = true
# Use ion-corrected atomic scattering factors (see `modules/x.py`)
# - false: neutral atom factors (default)
# - true: apply per-element ion correction term (currently defined for a subset, e.g. C+)
ion_mode_bool = false
# Use PCD (Percent Change Difference) mode for target function
pcd_mode_bool = true
# Excitation factor for scaling target function (used in "normal" mode)
excitation_factor = 1.0

# Q-vector parameters (scattering vector magnitude)
[scattering_params.q]
# Minimum q value (Å⁻¹)
qmin = 0.4
# Maximum q value (Å⁻¹)
qmax = 4.0
# Number of q points
qlen = 100

# Ewald sphere parameters (3D scattering mode)
[scattering_params.ewald]
# Use Ewald sphere mode (3D scattering) instead of isotropic 1D
ewald_mode_bool = false

# Theta parameters (polar angle, units of π) - used in Ewald mode
[scattering_params.ewald.th]
# Minimum theta value
tmin = 0.0
# Maximum theta value
tmax = 1.0
# Number of theta points
tlen = 21

# Phi parameters (azimuthal angle, units of π) - used in Ewald mode
[scattering_params.ewald.ph]
# Minimum phi value
pmin = 0.0
# Maximum phi value
pmax = 2.0
# Number of phi points
plen = 21

# Noise parameters (Adds noise to the signal for "test" mode)
[scattering_params.noise]
# Standard deviation of noise to add to target function
noise_value = 0.0
# Path to noise data file (if file exists, reads from file; otherwise generates random noise and saves to data directory)
noise_data_file = "data/noise.dat"

# ============================================================================
# SIMULATED ANNEALING PARAMETERS
# ============================================================================
[simulated_annealing_params]
# Starting temperature for simulated annealing (controls acceptance probability)
sa_starting_temp = 1.0
# Number of steps in simulated annealing phase
sa_nsteps = 4000
# Enable greedy algorithm phase after simulated annealing
greedy_algorithm_bool = true
# Number of steps in greedy algorithm phase
ga_nsteps = 4000
# Step size for simulated annealing (controls displacement magnitude)
sa_step_size = 0.012
# Step size for greedy algorithm
ga_step_size = 0.012
# Number of restarts (each restart uses best structure from previous restart)
nrestarts = 5
# Total number of runs (repeats entire process ntotalruns times)
ntotalruns = 5
# Enable bond length constraints (harmonic oscillator potential)
bonds_bool = true
# Enable bond angle constraints (harmonic oscillator potential)
angles_bool = true
# Enable torsion angle constraints (harmonic oscillator potential)
torsions_bool = true
# Target ratio of X-ray contribution to total objective function
tuning_ratio_target = 0.5
# Initial tuning constant (C_tuning) for balancing X-ray vs. geometric constraints
c_tuning_initial = 0.01
# Only use non-hydrogen normal modes in optimization
non_h_modes_only_bool = false
# Damping factor for hydrogen modes (multiplies step size for hydrogen modes, typically < 1.0)
hydrogen_mode_damping_factor = 0.2
# Run PySCF Hartree-Fock energy calculation
hf_energy_bool = false

# ============================================================================
# MOLECULE-SPECIFIC PARAMETERS: CHD (1,3-Cyclohexadiene)
# ============================================================================
[molecule_params.chd]
# Number of atoms in the molecule
natoms = 14
# Total number of normal modes (3N-6 for non-linear molecules)
nmodes = 36
# Range of hydrogen modes [start, end) - modes to exclude or handle specially
hydrogen_mode_range = [28, 36]
# Range of modes to use in simulated annealing phase [start, end)
sa_mode_range = [0, 36]
# Range of modes to use in greedy algorithm phase [start, end)
ga_mode_range = [0, 36]
# Bonds to ignore in constraint calculations (atom indices: [atom1, atom2])
bond_ignore_array = []
# Angles to ignore in constraint calculations (atom indices: [atom1, atom2, atom3])
angle_ignore_array = []
# Torsions to ignore in constraint calculations (atom indices: [atom1, atom2, atom3, atom4])
torsion_ignore_array = []
# Atom indices to use for RMSD calculation (compared to reference structure)
rmsd_indices = [0, 1, 2, 3, 4, 5]
# Atom indices defining bonds to monitor/constrain (atom indices: [atom1, atom2])
bond_indices = [0, 5]
# Atom indices defining angles to monitor/constrain (atom indices: [atom1, atom2, atom3])
angle_indices = [0, 3, 5]
# Atom indices defining dihedrals to monitor/constrain (atom indices: [atom1, atom2, atom3, atom4])
dihedral_indices = [0, 1, 4, 5]

# ============================================================================
# MOLECULE-SPECIFIC PARAMETERS: NMM (N-methylmorpholine)
# ============================================================================
[molecule_params.nmm]
# Number of atoms in the molecule
natoms = 18
# Total number of normal modes (3N-6 for non-linear molecules)
nmodes = 48
# Range of hydrogen modes [start, end) - modes to exclude or handle specially
hydrogen_mode_range = [38, 48]
# Range of modes to use in simulated annealing phase [start, end)
sa_mode_range = [0, 48]
# Range of modes to use in greedy algorithm phase [start, end)
ga_mode_range = [0, 48]
# Bonds to ignore in constraint calculations (atom indices: [atom1, atom2])
bond_ignore_array = []
# Angles to ignore in constraint calculations (atom indices: [atom1, atom2, atom3])
angle_ignore_array = [[6, 3, 1], [6, 3, 5]]
# Torsions to ignore in constraint calculations (atom indices: [atom1, atom2, atom3, atom4])
torsion_ignore_array = [
    [0, 1, 3, 6],
    [1, 3, 6, 7],
    [1, 3, 6, 8],
    [1, 3, 6, 9],
    [5, 3, 6, 7],
    [5, 3, 6, 8],
    [5, 3, 6, 9],
    [2, 1, 3, 6],
    [4, 1, 3, 6],
    [6, 3, 5, 10],
    [6, 3, 5, 16],
    [6, 3, 5, 17]
]
# Atom indices to use for RMSD calculation (compared to reference structure)
rmsd_indices = [3, 5, 6, 10, 12, 0, 1]
# Atom indices defining bonds to monitor/constrain (atom indices: [atom1, atom2])
bond_indices = [6, 12]
# Atom indices defining angles to monitor/constrain (atom indices: [atom1, atom2, atom3])
angle_indices = [6, 3, 12]
# Atom indices defining dihedrals to monitor/constrain (atom indices: [atom1, atom2, atom3, atom4])
dihedral_indices = [6, 3, 5, 10]
